/* "use client"; // Importante: Context solo vive en el cliente

import { createContext, useContext, useState, ReactNode } from 'react';

// 1. Definimos la forma de los datos
interface UserData {
  token: string;
  idUser:string;
  name: string;
  role: string;
  slug?: string;
  businessId?:string;
}

interface UserContextType {
  user: UserData | null;
  setUser: (user: UserData | null) => void;
}

// 2. Creamos el contexto
const UserContext = createContext<UserContextType | undefined>(undefined);

// 3. Proveedor del contexto
export function UserProvider({ children, initialUser }: { children: ReactNode, initialUser: UserData | null }) {
  const [user, setUser] = useState<UserData | null>(initialUser);

  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  );
}

// 4. Hook personalizado para usar el contexto fácilmente
export function useUser() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error("useUser debe usarse dentro de un UserProvider");
  }
  return context;
} */

  /// nuevo para httpOnly

  "use client";

import { createContext, useContext, useState, useEffect, ReactNode } from 'react';

// 1. Refinamos la interfaz: Eliminamos el 'token' por seguridad.
// El token ahora vive en una Cookie HttpOnly invisible para este código.
interface UserData {
  idUser: string;
  name: string;
  role: string;
  slug?: string;
  businessId?: string;
}

interface UserContextType {
  user: UserData | null;
  setUser: (user: UserData | null) => void;
  loading: boolean; // Añadimos loading para saber cuando la sesión se está verificando
}

const UserContext = createContext<UserContextType | undefined>(undefined);

export function UserProvider({ children, initialUser }: { children: ReactNode, initialUser: UserData | null }) {
  const [user, setUser] = useState<UserData | null>(initialUser);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Esta función verifica si hay una sesión activa al cargar la app
    const verifySession = async () => {
      try {
        // Llamamos al endpoint /me que creamos en el backend
        // No enviamos token en el header, 'credentials: include' lo hace por nosotros
        const res = await fetch("http://localhost:4000/api/auth/me", {
          method: "GET",
          credentials: "include", 
        });

        if (res.ok) {
          const data = await res.json();
        
          setUser(data.user); // Llenamos el contexto con los datos (name, role, slug, etc.)
          console.log("user desde UserContex ", user)
          
        } else {
          setUser(null); // Si el token expiró o no existe, limpiamos el usuario
        }
      } catch (error) {
        console.error("Error verificando sesión activa");
        setUser(null);
      } finally {
        setLoading(false);
      }
    };

    // Si ya tenemos un initialUser (desde el servidor), no hace falta verificar de nuevo
    if (!initialUser) {
      verifySession();
    } else {
      setLoading(false);
    }
  }, [initialUser]);

  //console.log("desde contestx me Data ", user)

  return (
    <UserContext.Provider value={{ user, setUser, loading }}>
      {/* Evitamos flashes de contenido: Mientras carga, podrías mostrar un spinner 
        o simplemente esperar a que 'loading' sea false para renderizar la app protegida
      */}
      {children}
    </UserContext.Provider>
  );
}

export function useUser() {
 /*  const context = useContext(UserContext);// chrasea(da eero porque es muy estricto al serrar sesion queda algo montado por un milisegundo y da error)
  if (!context) {
    throw new Error("useUser debe usarse dentro de un UserProvider");
  }
  return context; */

  const context = useContext(UserContext);
  
 // En lugar de lanzar el error inmediatamente, 
 if (context === undefined) {
    return { 
      user: null, 
      setUser: () => {}, 
      loading: false 
    }; 
  }
  
  return context;
}